import jsPDF from 'jspdf'
import { parseLetterStructure, isDate, isSalutation, isClosing } from '../utils/letterParser'

class PDFService {
  /**
   * Generate PDF from letter content with proper Malaysian letter format
   */
  generateLetterPDF(letterContent, metadata = {}) {
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    })

    const pageWidth = doc.internal.pageSize.getWidth()
    const pageHeight = doc.internal.pageSize.getHeight()
    const margin = 25
    const maxWidth = pageWidth - (margin * 2)

    // Extract text from HTML
    const letterData = this.parseLetterStructure(letterContent)

    let y = margin

    // Set default font
    doc.setFont('helvetica', 'normal')
    doc.setFontSize(11)
    doc.setTextColor(0, 0, 0)

    // ===== SENDER SECTION (Top Left) =====
    if (letterData.sender.length > 0) {
      letterData.sender.forEach(line => {
        if (line.trim()) {
          doc.text(line.trim(), margin, y)
          y += 5
        }
      })
      y += 5 // Extra space after sender
    }

    // ===== HORIZONTAL LINE =====
    doc.setLineWidth(0.5)
    doc.setDrawColor(0, 0, 0)
    doc.line(margin, y, pageWidth - margin, y)
    y += 8 // Space after line

    // ===== RECIPIENT NAME (Top, Left-aligned) =====
    if (letterData.recipientName) {
      doc.text(letterData.recipientName.trim(), margin, y)
      y += 5
    }

    // ===== RECIPIENT ADDRESS (Left-aligned) with DATE (Right-aligned on same line) =====
    if (letterData.recipient.length > 0) {
      letterData.recipient.forEach((line, index) => {
        if (line.trim()) {
          doc.text(line.trim(), margin, y)
          
          // If this is the LAST recipient line AND we have a date,
          // put the date on the same line (right-aligned)
          if (index === letterData.recipient.length - 1 && letterData.date) {
            const dateX = pageWidth - margin - doc.getTextWidth(letterData.date)
            doc.text(letterData.date, dateX, y)
          }
          
          y += 5
        }
      })
      y += 8 // Extra space after recipient
    } else if (letterData.date) {
      // If no recipient address but we have date, put it on right
      const dateX = pageWidth - margin - doc.getTextWidth(letterData.date)
      doc.text(letterData.date, dateX, y)
      y += 10
    }

    // ===== SALUTATION =====
    if (letterData.salutation) {
      doc.text(letterData.salutation, margin, y)
      y += 8 // Space after salutation
    }

    // ===== SUBJECT LINE (Bold and Underlined) - AFTER SALUTATION =====
    if (letterData.subject) {
      y += 2 // Small extra space before subject
      doc.setFont('helvetica', 'bold')
      const subjectText = letterData.subject
      doc.text(subjectText, margin, y)
      
      // Underline
      const subjectWidth = doc.getTextWidth(subjectText)
      doc.setLineWidth(0.3)
      doc.line(margin, y + 1, margin + subjectWidth, y + 1)
      
      y += 10 // Extra space after subject
      doc.setFont('helvetica', 'normal')
    }

    // ===== BODY PARAGRAPHS =====
    letterData.body.forEach((paragraph, index) => {
      if (paragraph.trim()) {
        // Check for page break
        const estimatedHeight = Math.ceil(paragraph.length / 80) * 5 + 8
        if (y + estimatedHeight > pageHeight - margin - 20) {
          doc.addPage()
          y = margin
        }

        const wrappedText = doc.splitTextToSize(paragraph.trim(), maxWidth)
        doc.text(wrappedText, margin, y)
        y += wrappedText.length * 5
        y += 8 // Space between paragraphs
      }
    })

    // ===== CLOSING =====
    if (letterData.closing) {
      if (y > pageHeight - margin - 30) {
        doc.addPage()
        y = margin
      }
      doc.text(letterData.closing, margin, y)
      y += 5
    }

    // ===== SIGNATURE NAME =====
    if (letterData.signatureName) {
      if (y > pageHeight - margin - 20) {
        doc.addPage()
        y = margin
      }
      doc.text(letterData.signatureName, margin, y)
    }

    // Add footer
    this.addFooter(doc, metadata)

    return doc
  }


  /**
   * Add footer to PDF with metadata
   */
  addFooter(doc, metadata) {
    const pageHeight = doc.internal.pageSize.getHeight()
    const pageWidth = doc.internal.pageSize.getWidth()

    const footerY = pageHeight - 15
    doc.setFontSize(8)
    doc.setTextColor(150, 150, 150)
    doc.setFont('helvetica', 'normal')

    const letterType = this.formatLetterType(metadata?.letter_type)
    const language = this.formatLanguage(metadata?.language)
    const date = new Date().toLocaleDateString('en-MY', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    })

    const footerText = `Generated by Catat • ${letterType} • ${language} • ${date}`
    
    const textWidth = doc.getTextWidth(footerText)
    const centerX = (pageWidth - textWidth) / 2
    
    doc.text(footerText, centerX, footerY)
  }

  /**
   * Format letter type for display
   */
  formatLetterType(type) {
    const types = {
      complaint: 'Complaint Letter',
      proposal: 'Proposal',
      mc: 'MC Letter',
      general: 'General Letter',
      official: 'Official Letter'
    }
    return types[type] || 'Letter'
  }

  /**
   * Format language for display
   */
  formatLanguage(lang) {
    const languages = {
      en: 'English',
      ms: 'Bahasa Malaysia',
      mixed: 'Mixed'
    }
    return languages[lang] || 'English'
  }

  /**
   * Download PDF to user's device
   */
  downloadPDF(doc, filename = 'letter.pdf') {
    doc.save(filename)
  }

  /**
   * Open PDF in new browser tab
   */
  openPDFInNewTab(doc) {
    const pdfBlob = doc.output('blob')
    const url = URL.createObjectURL(pdfBlob)
    window.open(url, '_blank')
  }

  /**
   * Get PDF as blob (for uploading to storage)
   */
  getPDFBlob(doc) {
    return doc.output('blob')
  }

  /**
   * Get PDF as base64 string
   */
  getPDFBase64(doc) {
    return doc.output('datauristring')
  }
}

export const pdfService = new PDFService()